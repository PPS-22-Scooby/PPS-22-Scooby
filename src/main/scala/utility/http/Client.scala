package org.unibo.scooby
package utility.http

import utility.http.Configuration.ClientConfiguration

import scala.concurrent.duration.Duration

/**
 * Core of the HTTP logic. A [[HttpClient]] can mix-in a Backend to gain the corresponding, underlying implementation of
 * HTTP calls. Each Backend must specify the type of the generated HTTP responses: it can also (and in fact should) be a
 * type that does not depend on the underlying HTTP library.
 *
 * Note that while the [[Request]] type is used inside all the backends, the response's one [[R]] is specific to the
 * used Backend.
 *
 * @tparam R
 *   type of the HTTP responses generated by the Backend
 */
trait Backend[R] extends HttpClient:
  /**
   * Sends the provided [[Request]] using the Backend implementation
   *
   * @param request
   *   request to be sent
   * @return
   *   a response of type [[R]], depending on the Backend implementation
   */
  def send(request: Request): R

/**
 * Empty trait that represents an HTTP client. To be useful, you need to mix-in [[Backend]] Traits
 */
trait HttpClient(configuration: ClientConfiguration)

object Clients:
  import utility.http.backends.SttpSyncBackend

  /**
   * Simple HTTP client used for synchronous HTTP calls with the sttp library as backend
   */
  class SimpleHttpClient(configuration: ClientConfiguration = Configuration.default)
      extends HttpClient(configuration) with SttpSyncBackend

type Client[R] = HttpClient & Backend[R]

object Configuration:
  private type ConfigurationEntry = (ConfigurationEntryType, Any)

  enum ConfigurationEntryType(val valueType: Class[?]):
    case NETWORK_TIMEOUT extends ConfigurationEntryType(classOf[Duration])

  case class ClientConfiguration(configs: ConfigurationEntry*)

  object ClientConfiguration:
    def apply(configs: ConfigurationEntry*): Either[HttpError, ClientConfiguration] =
      configs.find {
        case (entryType: ConfigurationEntryType, value: Any) => value.getClass.isAssignableFrom(entryType.valueType)
      } match
        case Some((entryType: ConfigurationEntryType, entryValue: Any)) =>
          Left((s"$entryValue doesn't satisfy the type of configuration entry: $entryType which " +
            s"is ${entryType.valueType}").asHttpError)
        case None => Right(new ClientConfiguration(configs*))

  import ConfigurationEntryType.*
  import scala.concurrent.duration.DurationInt

  def default: ClientConfiguration = ClientConfiguration(NETWORK_TIMEOUT -> 5.seconds)
    .getOrElse(new ClientConfiguration())
